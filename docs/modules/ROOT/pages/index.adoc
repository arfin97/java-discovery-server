= Discovery Server!

== Introduction
This module we'll look at how service discovery helps you locate your application services in the cloud.

* First we're going to look at *service discovery*. Obviously this module's about service discovery, so we'll talk about what it is and why it's important. 
* Then, we're going to look at how Spring Cloud implements service discovery. It uses a project from Netflix that was open sourced, it's called Eureka, and we're going to talk about the *Eureka Client and the Eureka Server.* 
* Then, we'll move on to configuration, *configuring the Eureka Client, the Eureka Server*, and the Eureka Instance and how each of those are different and what you need to do to tweak them or configure them for your needs. 
* Then, we'll move into *health and high availability*. How does the Eureka Server know when your application is down or when it's unhealthy? And how do you ensure that the Eureka Server is highly available? 
* And then we're going to look at the *Eureka Dashboard*, which is a nice web UI that shows you all of your registered services, how many instances there are, and whether they're up or down. 
* And last, we're going to finish out with how Eureka has specific *support for AWS.*

== Service discovery?
Let's get started with the most important question, what is service discovery and why do we need it? Remember that the cloud is changing the way that we build software. We're moving from building these single large applications and instead breaking them up into smaller and smaller pieces called services. And each of those individual services can then be deployed and scaled on their own, and together, as a whole, they form the overall application. And herein lies the problem. How does one service know where another service is at, its host and its port, so that it can call it and use it? For starters, we could simply configure all of our services to know the location and the port of other services that it calls. And, depending on our needs, this actually might get us pretty far. But after a while, we'll learn that there are some problems to this approach. What if, for example, you had two instances of a particular service?

* A way for a service to register itself. And what that means is that when a service comes online it can call out to the Service Discovery Server and let it know the location and port of its service so that other application services can call it. 

* For the exact opposite reasons, service discovery provides a way for a service to deregister itself. So if a service were to shut down or go away temporarily for upgrades, it would want to let the Service Discovery Server know that it's no longer available for clients to use. And, most importantly, service discovery provides a way for clients to find other services. 

* And what do I mean by clients? Well I mean other application services. So if you're an application service that needs to use another service, you need to be able to find the location and port of that service, and you can ask the Service Discovery Server for that information. 

* Lastly, service discovery provides a way to check the health of a service and remove any unhealthy instances. So each application service would implement a health check, typically via a REST endpoint, and then the Service Discovery Server would call that endpoint. And if the health check were to fail, it would remove that instance from its registry.

== Spring Cloud Eureka

There are actually several different ways that you can discover services using Spring Cloud. There's the 

* Spring Cloud Consul project, 
* there's the Spring Cloud Zookeeper project, and there's 
* the Spring Cloud Netflix project. 

== Key Components Involved in Service Discovery

1. There's the Discovery Server, 
2. the application service, 
3. and the application client

 * The first thing that happens is the application service starts up. And when it starts up, it calls out to the Discovery Server, and it registers itself. 
 
 * And it tells the Discovery Server its location, its port, and a service identifier that others can use to find it. 
 
 * Then at some point later, a client needs to call that application service, but it doesn't know the location and the port of the service, so it needs to ask the Discovery Server. 
 
 * It sends out a request to the Discovery Server and sends along the service identifier. And the Discovery Server knows that based on that service identifier which service you're asking for, and it responds back with the location and the port of that service. 
 
 * From there, things proceed as normal, and the client can request the service and its location, and the service can respond back with data.
 
== The Discovery Server

At its core, the Discovery Server is an actively managed registry of service locations. It is responsible for allowing others to find services and for services to register and deregister themselves.

=== Create a discovery server.

1. In your pom. xml of your Maven project, in the dependencyManagement section, define a new dependency called spring-cloud-dependencies, and make sure it's of type pom and it has a scope of import. Still within your pom. xml, define a new dependency, spring-cloud-starter-eureka-server.

2. application. properties or your application. yml, define a new property, spring. application. name. And you can give this whatever value you want. In our case here, we're going to use discovery-server. 

3. Then, in your main Application class, you literally define one annotation. It's @EnableEurekaServer. And that's all there is to it. Once you start this application up, you will having a running instance of a Discovery Server.

* Let's scroll up to one of these exceptions and see what the problem is. Cannot execute request on any known server. And if you look, it's coming from this DiscoveryClient. register method. And what's happening is the Service Discovery Server is starting up, and it's trying to register itself with a peer Service Discovery Server. And this is mainly for high availability purposes. However, when we're running in standalone or development mode, it can kind of be a pain to have to set up multiple instances every time. So instead, we're going to configure the Eureka Server not to try to register itself with its peers.


* open up the application. properties. The first property we're going to add is actually one that we forgot previously, it's the spring. application. name property, and we're going to set that to discovery-server. The second property we're going to add is a Eureka Client property, so go ahead and type eureka. client. register-with-eureka. And since we're the Discovery Server our self, and we're running in standalone mode, we don't need to register with any other peers because there aren't any other peers. So make sure you set that value to false. The next property is also a Eureka Client property, so go ahead and type eureka. client. fetch-registry. And this property controls whether or not the Eureka Client would fetch the registry from the Eureka Server, and since we are the only Eureka Server, there's nothing else to fetch from anybody else, so we'll set this to false. And the last property we're going to add is the server. port, and we're going to set that to a value of 8761, which is the default port for Eureka Discovery Server. Once you get those properties in place, head over to the main application class, right-click on it, and go to Run As Spring Boot App. When your app finishes starting up, expand the console, and you'll see that it started the Eureka Server and it changed its status to UP. So you now have a running Service Discovery Server.


== The Application Service - The Client

add a new dependency within the dependencies elements, and this one is called spring-cloud-starter-eureka. Then in your application. properties or your application. yml, add two new properties. The first property is the spring. application. name property, and again you can set this to whatever value you want. In our case, we'll use service. The second property tells the application service where the Service Discovery Server is located, and it's the eureka. client. defaultZone property. And you can see we set that to localhost, but in a production configuration you'd obviously set that to wherever your Service Discovery Server was located. If you're wondering what the defaultZone piece is of the property, don't worry about it for now. We'll explain more about that in the AWS support section. And then in your main Application class of your application service, you add one annotation. Again, it's just one annotation. The Spring Cloud guys have made it so easy for us. And that is the @EnableDiscoveryClient annotation. And what this does is it makes our application service register itself with the Discovery Server, and then other services can find it.

eureka.client.service-url.defaultZone=http://localhost8731/eureka

Demo
* Eureka Discovery
* DevTools
* Actuator

== The Application Client
=== Creating Multiple Instance of same client using different configuration settings.

 
 
 
 
 
 
 
 
 
 
 
 